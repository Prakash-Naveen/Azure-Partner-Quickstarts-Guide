
<b>•</b> Minimize parameters whenever possible. If you can use a variable or a literal, do so. Only provide parameters for:<br/>
  &nbsp;o	Settings you wish to vary by environment (such as sku, size, or capacity).<br/>
  &nbsp;o	Resource names you wish to specify for easy identification.<br/>
  &nbsp;o	Values you use often to complete other tasks (such as admin user name).<br/>
  &nbsp;o	Secrets (such as passwords)<br/>
  &nbsp;o	The number or array of values to use when creating multiple instances of a resource type.<br/><br/><br/>
<b>•</b> Parameter names should follow camelCasing.<br/>
<b>•</b>	Provide a description in the metadata for every parameter.<br/>
<b>•</b>	Define default values for parameters (except for passwords and SSH keys).<br/> 
<b>•</b>	Use securestring for all passwords and secrets.<br/>
<b>•</b>	Any resources that need to be setup outside the template should be named prefixed with existing (e.g. existingVNET,
existingDiagnosticsStorageAccount).<br/>
<b>•</b>	When possible, avoid using a parameter to specify the location. Instead, use the location property of the resource group. By using the resourceGroup().location expression for all your resources, the resources in the template are deployed in the same location as the resource group.<br/>
<b>•</b>	If a resource type is supported in only a limited number of locations, consider specifying a valid location directly in the template.If you must use a location parameter, share that parameter value as much as possible with resources that are likely to be in the same 
location. This approach minimizes users having to provide locations for every resource type.<br/>
<b>•</b>	Avoid using a parameter or variable for the API version for a resource type. Resource properties and values can vary by version number.<br/><br/>
Intellisense in code editors is not able to determine the correct schema when the API version is set to a parameter or variable. Instead, hard-code the API version in the template.<br/>
<b>•</b> Do not create a parameter for a <b>storage account name</b>. Storage account names need to be lower case and can't contain hyphens (-) in addition to other domain name restrictions. A storage account has a limit of 24 characters. They also need to be globally unique. To prevent any validation issue, configure a variables (using the expression <b>uniqueString</b> and a static value <b>storage</b> ). Storage accounts with a common prefix (uniqueString) will not get clustered on the same racks.<br/>

<blockquote> 
"variables": {<br>
     "storage": {<br>
         "name": "[concat(uniqueString(resourceGroup().id),'storage')]",<br>
         "type": "Standard_LRS"<br>
     }<br>
 },<br>
 "resources": [
   {
       "type": "Microsoft.Storage/storageAccounts",
       "name": "[variables('storage').name]",
       "apiVersion": "2016-01-01",
       "location": "[resourceGroup().location]",
       "sku": {
           "name": "[variables('storage').type]"
       },
       ...
   }
 ]
 
 </blockquote> 
 <br/>
 <b>•</b> For many resources with a resource group, a name is not often relevant and using something a hard coded string "availabilitySet" may be acceptable. You can also use variables for the name of a resource and generate names for resources with globally unique names. Use <b>displayName</b> tags for a "friendly" name in the JSON outline view. This should ideally match the name property value or property name.<br/>
<p>
"resources": [
 {
   "name": "availabilitySet",
   "type": "Microsoft.Compute/availabilitySets",
   "apiVersion": "2015-06-15",
   "location": "[resourceGroup().location]",
   "tags": { "displayName": "appTierAS" },
   "properties": {
      ...
   }
}
]
</p>



